@name dragonscript/animations
@inputs 
@outputs 

@persist IT_Pitch IT_Pitch_Old IT_Yaw IT_Roll LeftWing_Rand RightWing_Rand JawTheta
@persist [FLPO FRPO RLPO RRPO]:vector FLPQ FRPQ RLPQ RRPQ
@persist LanternTheta BlushTheta BlushQ
@trigger 

AnimVersion = "2.2.6"

local NeedFudge = !entity():getName():find("Magnums Dragon 2")
if(NeedFudge){
    #Jaw/Blep
    JawAngleMaster = 0
    Blepping = 0
    TongueHolos = array()
    TongueLeftToothHolo = 0
    TongueRightToothHolo = 0
    PupilHolos = array()
    PupilScale = 1
    EyeScale = vec()
    ColorEye = vec()
    ColorPupil = vec()
    ColorEyeLid = vec()
    MatEye = ""
    MatPupil = ""
    MatEyeLid = ""
    DefaultExpression = "normal"
    Mlemming = 0
    MlemAngle = 0
    MlemLoop = 0
    MlemSound = ""
    Scale = 1
    
    TearColor = vec4()
    TearHolos = array()
    BlushColor = vec4()
    BlushHolos = array()
    FilterEnts = array()
}


function vector scp(V:vector,Scale){ #Scale Processing
    local X = V:x()*Scale
    local Y = V:y()*Scale
    local Z = -18 + (V:z()+18)*Scale
    return vec(X,Y,Z)
}

function number linterp(T,Start:vector2,End:vector2){ #2-Point Linear Interpolation
    
    local X0 = Start:x()
    local X1 = End:x()
    local Y0 = Start:y()
    local Y1 = End:y()
    
    if((T>=X0)&(T<X1)){
        local TN = (T-X0)/(X1-X0)
        return Y0 + TN*(Y1-Y0)
    }else{
        return 0
    }
}
function number linterpsat(T,Start:vector2,End:vector2){ #2-Point Linear Interpolation - saturable
    
    local X0 = Start:x()
    local X1 = End:x()
    local Y0 = Start:y()
    local Y1 = End:y()
    
    if((T>=X0)&(T<X1)){
        local TN = (T-X0)/(X1-X0)
        return Y0 + TN*(Y1-Y0)
    }elseif(T<X0){ #Low out of range
        return Y0
    }else{
        return Y1 #High out of range
    }
}

function array ikstep(StepLength,WalkSpeed,PhaseOffset,ParmData,Scale){ #Gives "Local" Vector; ParmData -1 to +1
    
    local X = 0
    local Z = 0
    #local StepHeight = clamp(abs(WalkSpeed)*0.75,10,16)
    local StepHeight = clamp(abs(WalkSpeed)*0.75,0,16)
    
    if(WalkSpeed!=0){
        
        StepLength = clamp(abs(StepLength),1,24)
        
        ParmData -= WalkSpeed/(StepLength*2)
        
        if(ParmData > 1){
            ParmData -= 2
        }elseif(ParmData < -1){
            ParmData += 2
        }
        
        local PD = ParmData + PhaseOffset
        if(PD > 1){
            PD -= 2
        }elseif(PD < -1){
            PD += 2
        }
        
        if(PD<=0){ #Negative; Treading on Ground. -1 to 0
            X = -StepLength + (PD+1)*2*(StepLength)
            Z = 0
        }elseif(PD>0){ #Positive; Taking next Step. 0 to 1
            X = StepLength - PD*2*(StepLength)
            local A = -StepHeight/(StepLength^2)
            Z = A*(X^2) + StepHeight
        }
            
    }
    
    return array(vec(X,0,Z)*Scale,ParmData)
}
function void legReset(){ #Reset Legs for IK
    FLPQ = FRPQ = RLPQ = RRPQ = 0
}

function void entity:posReset(Axis:vector,Crouch,Scale){ #Reset position of E2 to compensate for crouching
    rangerFilter(This)
    rangerFilter(FilterEnts)
    local StandRanger = rangerOffsetHull(This:pos(),This:pos() - Axis*96, vec(32,32,0)*Scale)
    if(StandRanger:hit()){This:setPos(StandRanger:pos() + Axis*(Crouch ? 12 : 18))}
}

function void entity:iklegs(FLP:vector, FRP:vector, RLP:vector, RRP:vector, Scale){ #Inputs local to E2
    local E = This
    rangerFilter(entity())
    rangerDefaultZero(0)
    
    #3 Left Shoulder
    #92 Left Elbow
    #4 Left Front Foot (24,7,-34)
    
    local Thigh = 18*Scale
    local Shin = 18*Scale
    local Hip = holoEntity(3)
    local Knee = holoEntity(92)
    local Foot = holoEntity(4)
    local R = rangerOffset(Hip:pos(),E:toWorld(vec(24,7,-36)*Scale+FLP))
    local TreadPos = (E:toLocal(R:pos())+vec(0,-7,0)*Scale)*vec(1,-1,1) + vec(0,7,0)*Scale
    if((TreadPos==FLPO) & (FLPQ<10)){
        FLPQ++
    }elseif(TreadPos!=FLPO){
        FLPQ = 0
    }
    FLPO = TreadPos
    if(FLPQ<10){
        local Distance = clamp(R:distance(),12*Scale,Shin+Thigh-1)
        local Theta_a = acos((Shin^2 + Thigh^2 - Distance^2)/(2*Thigh*Shin)) #Knee
        local Theta_b = asin((Shin/Distance)*sin(Theta_a)) #Hip
        local Theta_c = 180 - Theta_a - Theta_b #Foot
        local Axis = TreadPos - vec(24,7,0)*Scale
        local Ang_h_f = -heading(vec(),ang(-90,0,0),-Axis) + ang(-90,0,0)
    
        local HipAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),Theta_b+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        local KneeAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),-Theta_c+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        
        local FootAngle = ang(15,0,0)
        if(R:hit()){
            local RelevantVector = E:toLocalAxis(R:hitNormal())*vec(1,0,1)
            local Phi = elevation(vec(),ang(90,0,0),RelevantVector)
            FootAngle = ang(Phi,0,0)
        }
        
        holoAng(3,E:toWorld(HipAngle))
        holoAng(92,E:toWorld(KneeAngle))
        holoAng(4,E:toWorld(FootAngle))
    }
    
    #5 Right Shoulder
    #93 Right Elbow
    #6 Right Front Foot (24,-7,-34)
    
    
    local Thigh = 18*Scale
    local Shin = 18*Scale
    local Hip = holoEntity(5)
    local Knee = holoEntity(93)
    local Foot = holoEntity(6)
    local R = rangerOffset(Hip:pos(),E:toWorld(vec(24,-7,-36)*Scale+FRP))
    local TreadPos = (E:toLocal(R:pos())+vec(0,7,0)*Scale)*vec(1,-1,1) + vec(0,-7,0)*Scale
    if((TreadPos==FRPO) & (FRPQ<10)){
        FRPQ++
    }elseif(TreadPos!=FRPO){
        FRPQ = 0
    }
    FRPO = TreadPos
    if(FRPQ<10){
        local Distance = clamp(R:distance(),12*Scale,Shin+Thigh-1)
        local Theta_a = acos((Shin^2 + Thigh^2 - Distance^2)/(2*Thigh*Shin)) #Knee
        local Theta_b = asin((Shin/Distance)*sin(Theta_a)) #Hip
        local Theta_c = 180 - Theta_a - Theta_b #Foot
        local Axis = TreadPos - vec(24,-7,0)*Scale
        local Ang_h_f = -heading(vec(),ang(-90,0,0),-Axis) + ang(-90,0,0)
    
        local HipAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),Theta_b+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        local KneeAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),-Theta_c+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        
        local FootAngle = ang(15,0,0)
        if(R:hit()){
            local RelevantVector = E:toLocalAxis(R:hitNormal())*vec(1,0,1)
            local Phi = elevation(vec(),ang(90,0,0),RelevantVector)
            FootAngle = ang(Phi,0,0)
        }
        
        holoAng(5,E:toWorld(HipAngle))
        holoAng(93,E:toWorld(KneeAngle))
        holoAng(6,E:toWorld(FootAngle))
    }
    #7 Left Hip
    #94 Left Knee
    #8 Left Rear Foot (-20,7,-34)
    
    local Thigh = 12*Scale
    local Shin = 24*Scale
    local Hip = holoEntity(7)
    local Knee = holoEntity(94)
    local Foot = holoEntity(8)
    local R = rangerOffset(Hip:pos(),E:toWorld(vec(-20,7,-36)*Scale+RLP))
    local TreadPos = (E:toLocal(R:pos())+vec(0,-7,0)*Scale)*vec(1,-1,1) + vec(0,7,0)*Scale
    #print(E:toLocal(Hip:pos()))
    #print(round(TreadPos))
    if((TreadPos==RLPO) & (RLPQ<10)){
        RLPQ++
    }elseif(TreadPos!=RLPO){
        RLPQ = 0
    }
    RLPO = TreadPos
    if(RLPQ<10){
        #print("Moving 1")
        local Distance = clamp(R:distance(),20*Scale,Shin+Thigh-1)
        local Theta_a = acos((Shin^2 + Thigh^2 - Distance^2)/(2*Thigh*Shin)) #Knee
        local Theta_b = asin((Shin/Distance)*sin(Theta_a)) #Hip
        local Theta_c = 180 - Theta_a - Theta_b #Foot
        local Axis = TreadPos - vec(-20,7,0)*Scale
        local Ang_h_f = -heading(vec(),ang(-90,0,0),-Axis) + ang(-90,0,0)
    
        local HipAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),-Theta_b+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        local KneeAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),Theta_c+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        
        local FootAngle = ang(15,0,0)
        if(R:hit()){
            local RelevantVector = E:toLocalAxis(R:hitNormal())*vec(1,0,1)
            local Phi = elevation(vec(),ang(90,0,0),RelevantVector)
            FootAngle = ang(Phi,0,0)
        }
        
        holoAng(7,E:toWorld(HipAngle))
        holoAng(94,E:toWorld(KneeAngle))
        holoAng(8,E:toWorld(FootAngle))
    }
    
    #9 Right Hip
    #95 Right Knee
    #10 Right Rear Foot (-20,-7,-34)
    
    local Thigh = 12*Scale
    local Shin = 24*Scale
    local Hip = holoEntity(9)
    local Knee = holoEntity(95)
    local Foot = holoEntity(10)
    local R = rangerOffset(Hip:pos(),E:toWorld(vec(-20,-7,-36)*Scale+RRP))
    local TreadPos = (E:toLocal(R:pos())+vec(0,7,0)*Scale)*vec(1,-1,1) + vec(0,-7,0)*Scale
    if((TreadPos==RRPO) & (RRPQ<10)){
        RRPQ++
    }elseif(TreadPos!=RRPO){
        RRPQ = 0
    }
    RRPO = TreadPos
    #if(RRPQ<10){
    if(1){
        #print("Moving 2")
        local Distance = clamp(R:distance(),20*Scale,Shin+Thigh-1)
        #print(R:distance())
        local Theta_a = acos((Shin^2 + Thigh^2 - Distance^2)/(2*Thigh*Shin)) #Knee
        local Theta_b = asin((Shin/Distance)*sin(Theta_a)) #Hip
        local Theta_c = 180 - Theta_a - Theta_b #Foot
        local Axis = TreadPos - vec(-20,-7,0)*Scale
        local Ang_h_f = -heading(vec(),ang(-90,0,0),-Axis) + ang(-90,0,0)
        #print(Theta_a, Theta_b, Theta_c)
        local HipAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),-Theta_b+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        local KneeAngle = Ang_h_f:rotateAroundAxis(vec(0,1,0),Theta_c+90)#:rotateAroundAxis(Axis,Ang_h_f:yaw())
        
        local FootAngle = ang(15,0,0)
        if(R:hit()){
            local RelevantVector = E:toLocalAxis(R:hitNormal())*vec(1,0,1)
            local Phi = elevation(vec(),ang(90,0,0),RelevantVector)
            FootAngle = ang(Phi,0,0)
        }
        
        holoAng(9,E:toWorld(HipAngle))
        holoAng(95,E:toWorld(KneeAngle))
        holoAng(10,E:toWorld(FootAngle))
    }
    return void
}

function void entity:poseTail(Pitch,Yaw,Voffset,PoseType,Scale){
    local HitSolid = 1
    if((PoseType>0)){
        local E = entity()
        local TailRanger = rangerOffset(32*Scale,E:toWorld(scp(vec(-36,0,0),Scale)),-E:up())
        HitSolid = TailRanger:hit()
        #print(HitSolid)
    }
    if(HitSolid){
        Yaw = clamp(Yaw,-20,20)
        
        #holoPos(63,holoEntity(11):pos() + Voffset*This:up())
        
        holoPos(64,holoEntity(11):toWorld(vec(-16,-Yaw/9,0)*Scale))
        holoPos(65,holoEntity(64):toWorld(vec(-16,-Yaw/9,0)*Scale))
        holoPos(66,holoEntity(65):toWorld(vec(-16,-Yaw/9,0)*Scale))
        
        holoAng(11,This:toWorld(ang(Pitch,Yaw,0)))
        holoAng(64,This:toWorld(ang(Pitch,Yaw*2,0)))
        holoAng(65,This:toWorld(ang(Pitch,Yaw*3,0)))
        holoAng(66,This:toWorld(ang(Pitch,Yaw*4,0)))
        
        holoPos(11,holoEntity(0):toWorld(vec(-28,0,0)*Scale) + Voffset*This:up()*Scale)
    }elseif(PoseType==1){ #Sitting
        local PitchDown = 10
        local H0 = holoEntity(0)
        holoPos(64,holoEntity(11):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        holoPos(65,holoEntity(64):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        holoPos(66,holoEntity(65):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        
        holoAng(11,H0:toWorld(ang(-PitchDown*1,0,0)))
        holoAng(64,H0:toWorld(ang(-PitchDown*2,0,0)))
        holoAng(65,H0:toWorld(ang(-PitchDown*3,0,0)))
        holoAng(66,H0:toWorld(ang(-PitchDown*4,0,0)))
        holoPos(11,holoEntity(0):toWorld(vec(-28,0,0)*Scale) + Voffset*This:up()*Scale)
    }elseif(PoseType==2){ #Lying etc
        local PitchDown = 10
        local H0 = holoEntity(0)
        holoPos(64,holoEntity(11):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        holoPos(65,holoEntity(64):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        holoPos(66,holoEntity(65):toWorld(vec(-16,0,-PitchDown/9)*Scale))
        
        holoAng(11,H0:toWorld(ang(-PitchDown*3,0,0)))
        holoAng(64,H0:toWorld(ang(-PitchDown*4,0,0)))
        holoAng(65,H0:toWorld(ang(-PitchDown*5,0,0)))
        holoAng(66,H0:toWorld(ang(-PitchDown*6,0,0)))
        holoPos(11,holoEntity(0):toWorld(vec(-28,0,0)*Scale) + Voffset*This:up()*Scale)
    } 
    #holoPos(11,holoEntity(0):toWorld(vec(-28,0,Voffset)))

    
    
    
    
    return void
}
function vector2 entity:aimEyes(Target:vector){ #Produces a 2D vector for poseEyes()
    #5.5,6.5
    
    local FOV = 30
    
    local H2 = This
    local DiffAngle = -heading(H2:pos(),H2:angles(),Target)
    local Pitch = clamp(DiffAngle:pitch(),-FOV,FOV)
    local Yaw = clamp(DiffAngle:yaw(),-FOV,FOV)
    
    local X = Yaw/FOV#asin(Yaw)
    local Y = -Pitch/FOV#asin(Pitch)
    
    return vec2(X,Y)
}

function vector2 getEyeRoll(T){ #Produces a 2D vector for poseEyes()
    #T: -1 to +1
    #local TS = sin(T*90) #Blended T: -1 to +1
    #local TB = asin(T) #Antiblended T: -90 to +90
    #return vec2(cos(TB*2 + 90)*0.75,sin(TS*90 + 90))
    return vec2(-T*clamp(IT_Yaw,-30,30)/30,-(T^2)+1)
}

# sorry magnum i made this function ginormous with its arguments
function void entity:poseEyes(Direction:vector2,Close,Derp,Sex,Scale,Baby,Wink,CosmeticTable:table,UsePupilAngles,PupilCos:array){ #Moves Pupils, handles blinking/winking
    local LeftEyeScale = CosmeticTable:exists(30) ? CosmeticTable[30,table]["SCALE",vector] : vec(0.125)*PupilScale
    local RightEyeScale = CosmeticTable:exists(31) ? CosmeticTable[31,table]["SCALE",vector] : vec(0.125)*PupilScale
    
    if(Close){
        if(Sex){
            for(N=103,108){
                holoAlpha(N,0)
            }
        }
        local Head = This
        holoPos(30,Head:toWorld(vec(5.5,3,6.5)*Scale))
        holoPos(31,Head:toWorld(vec(5.5,-3,6.5)*Scale))
        
        local Mat = holoEntity(19):getMaterial()
        local ColorBody = holoEntity(19):getColor()
        holoMaterial(28,MatEyeLid)
        holoMaterial(29,MatEyeLid)
        holoColor(28,ColorEyeLid)
        holoColor(29,ColorEyeLid)
        holoColor(30,vec())
        holoColor(31,vec())
        holoScale(30,vec(0.125,0.25,0.0625)*EyeScale)
        holoScale(31,vec(0.125,0.25,0.0625)*EyeScale)
        
        # hide attached holos
        foreach(K,V:number=PupilCos){
            holoAlpha(V,0)
        }
        
    }else{
        if(Sex){
            for(N=103,105){
                holoAlpha(N,255*(Wink!=1))
            }
            for(N=106,108){
                holoAlpha(N,255*(Wink!=2))
            }
        }
        local Head = holoEntity(2)
        local X = Direction:x()
        local Y = Direction:y()
        
        local DX = (Derp ? -1 : 1)*X
        local DY = (Derp ? -1 : 1)*Y
        
        local LOX = ((X>0) ? 0.75*X : 0.5*X)
        local ROX = ((DX<0) ? 0.75*DX : 0.5*DX)
        local LOY = 0.5*Y
        local ROY = 0.5*DY
        
        local Pop = UsePupilAngles ? ((abs(X)+abs(Y))*0.125) : 0 # pushing out eyes slightly at extreme angles
        
        # unhide cosmetic holos
        foreach(K,V:number=PupilCos){
            holoAlpha(V,CosmeticTable[V,table]:exists("ALPHA") ? CosmeticTable[V,table]["ALPHA",number] : 255)
        }
        
        if(Wink==1){
            holoPos(30,Head:toWorld(vec(5.5,3,6.5)*Scale))
        }else{
            holoPos(30,Head:toWorld(vec(5.5+Pop,3 + LOX,6.5 + LOY)*Scale))
            if(UsePupilAngles){
                holoAng(30,Head:toWorld(ang(-Y*35,X*40,-15)))
            }
        }
        if(Wink==2){
            holoPos(31,Head:toWorld(vec(5.5,-3,6.5)*Scale))
        }else{
            holoPos(31,Head:toWorld(vec(5.5+Pop,-3 + ROX,6.5 + ROY)*Scale))
            if(UsePupilAngles){
                holoAng(31,Head:toWorld(ang(-Y*35,X*40,15)))
            }
        }

        holoMaterial(28,(Wink==1) ? MatEyeLid : MatEye)
        holoMaterial(29,(Wink==2) ? MatEyeLid : MatEye)
        holoColor(28,(Wink==1) ? ColorEyeLid : ColorEye)
        holoColor(29,(Wink==2) ? ColorEyeLid : ColorEye)
        holoColor(30,((Wink==1) ? vec() : ColorPupil))
        holoColor(31,((Wink==2) ? vec() : ColorPupil))
        holoScale(30,((Wink==1) ? vec(0.125,0.25,0.0625) : LeftEyeScale)*EyeScale)
        holoScale(31,((Wink==2) ? vec(0.125,0.25,0.0625) : RightEyeScale)*EyeScale)
    }
    
    #ifdef cameraAng(number,angle)
        local EPitch = -Direction:y()*30
        local EYaw = Direction:x()*30
        cameraAng(1,This:toWorld(ang(EPitch,EYaw,0)))
    #endif
    
    return void
}
function void entity:eyeExpression(Expr:string,Eyelids,Sex,Scale,Baby,Squint,Wink){ #Handles eye clips, eyelashes
    #holoClip(28,vec(0,0,1),vec(0,0,-1.5),0) #Confused
    
    #holoClip(28,vec(0,0,1),vec(0,0,-1.5),0) #Sad
    #holoClip(29,vec(0,0,1),vec(0,0,-1.5),0)
    
    #holoClip(28,vec(0,0,1.5),vec(0,1,-1.5),0) #Annoyed
    #holoClip(29,vec(0,0,1.5),vec(0,-1,-1.5),0)
    
    #holoClip(28,vec(0,0,1.5),vec(0,1,-1),0) #Angry
    #holoClip(29,vec(0,0,1.5),vec(0,-1,-1),0)
    
    local PLE = vec(5,3,6.5)*Scale
    local PRE = vec(5,-3,6.5)*Scale
    
    local SuperSquint = (Expr=="happy")|(Expr=="scared") #Expressions to trigger super squinting
    
    if((Squint & !SuperSquint) | (!Squint & SuperSquint)){ # happy just has the squint in order to achieve the effect
        holoClip(28,2,vec(0,0,-0.625)*EyeScale,vec(0,-0.25,1),0)
        holoClip(29,2,vec(0,0,-0.625)*EyeScale,vec(0,0.25,1),0)
    }elseif(Squint & SuperSquint){ # happy with squint desired is even more ludicrous
        holoClip(28,2,vec(0,0,-0.55)*EyeScale,vec(0,-0.25,1),0)
        holoClip(29,2,vec(0,0,-0.55)*EyeScale,vec(0,0.25,1),0)
    }else{
        holoClip(28,2,vec(0,0,-3)*EyeScale,vec(0,-0.25,1),0)
        holoClip(29,2,vec(0,0,-3)*EyeScale,vec(0,0.25,1),0)
    }
    
    #Spooped
    PupilScale = (Expr=="scared") ? 0.8125 : 1
    
    switch(Expr){
        case "happy", # i'm a filthy cheater
        case "normal",
            #Left Eye
            holoClip(28,vec(0,0,3)*EyeScale,vec(0,0,-1),0)
            holoClip(109,vec(0,0,3)*EyeScale,-vec(0,0,-1),0)
            
            holoPos(103,This:toWorld(PLE+vec(0,0.3,2.25)*EyeScale))
            holoAng(103,This:angles())
            
            holoPos(104,This:toWorld(PLE+vec(0,1.25,2)*EyeScale))
            holoAng(104,This:toWorld(ang(0,0,-30)))
            
            holoPos(105,This:toWorld(PLE+vec(0,1.75,1.25)*EyeScale))
            holoAng(105,This:toWorld(ang(0,0,-60)))
            
            #Right Eye
            holoClip(29,vec(0,0,3)*EyeScale,vec(0,0,-1),0)
            holoClip(110,vec(0,0,3)*EyeScale,-vec(0,0,-1),0)
            
            holoPos(106,This:toWorld(PRE+vec(0,-0.3,2.25)*EyeScale))
            holoAng(106,This:angles())
            
            holoPos(107,This:toWorld(PRE+vec(0,-1.25,2)*EyeScale))
            holoAng(107,This:toWorld(ang(0,0,30)))
            
            holoPos(108,This:toWorld(PRE+vec(0,-1.75,1.25)*EyeScale))
            holoAng(108,This:toWorld(ang(0,0,60)))
            break        
        case "confused",
            #Left Eye
            holoClip(28,vec(0,0,1)*EyeScale,vec(0,0,-1.5),0)
            holoClip(109,vec(0,0,1)*EyeScale,-vec(0,0,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.5,-0.35,1.7)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,-10)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.66,1.2)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,-20)))
            
            holoPos(105,This:toWorld(PLE+vec(0.375,1.65,0.5)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-30)))
            
            #Right Eye
            holoClip(29,vec(0,0,3)*EyeScale,vec(0,0,-1),0)
            holoClip(110,vec(0,0,3)*EyeScale,-vec(0,0,-1),0)
            
            holoPos(106,This:toWorld(PRE+vec(0,-0.3,2.25)*EyeScale))
            holoAng(106,This:angles())
            
            holoPos(107,This:toWorld(PRE+vec(0,-1.25,2)*EyeScale))
            holoAng(107,This:toWorld(ang(0,0,30)))
            
            holoPos(108,This:toWorld(PRE+vec(0,-1.75,1.25)*EyeScale))
            holoAng(108,This:toWorld(ang(0,0,60)))
            break
        case "sad",
            #Left Eye
            holoClip(28,vec(0,0,1)*EyeScale,vec(0,0,-1.5),0)
            holoClip(109,vec(0,0,1)*EyeScale,-vec(0,0,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.5,-0.35,1.7)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,-10)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.66,1.2)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,-20)))
            
            holoPos(105,This:toWorld(PLE+vec(0.375,1.65,0.5)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-30)))
            
            #Right Eye
            holoClip(29,vec(0,0,1)*EyeScale,vec(0,0,-1.5),0)
            holoClip(110,vec(0,0,1)*EyeScale,-vec(0,0,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.5,0.35,1.7)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,10)))
            
            holoPos(107,This:toWorld(PRE+vec(0.75,-0.66,1.2)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,20)))
            
            holoPos(108,This:toWorld(PRE+vec(0.375,-1.65,0.5)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,30)))
            break
        case "grumpy", #formerly annoyed
            #Left Eye
            holoClip(28,vec(0,0,1.5)*EyeScale,vec(0,1,-1.5),0)
            holoClip(109,vec(0,0,1.5)*EyeScale,-vec(0,1,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.375,-0.75,1.5)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,5)))
            
            holoPos(104,This:toWorld(PLE+vec(0.675,0.25,1.625)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,0)))
            
            holoPos(105,This:toWorld(PLE+vec(0.375,1.25,1.625)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-5)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.5)*EyeScale,vec(0,-1,-1.5),0)
            holoClip(110,vec(0,0,1.5)*EyeScale,-vec(0,-1,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.375,0.75,1.5)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-5)))
            
            holoPos(107,This:toWorld(PRE+vec(0.675,-0.25,1.625)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,0)))
            
            holoPos(108,This:toWorld(PRE+vec(0.375,-1.25,1.625)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,5)))
            
            
            break
        case "annoyed", #formerly smug
            #Left Eye
            holoClip(28,vec(0,0,1.0)*EyeScale,vec(0,1,-1.5),0)
            holoClip(109,vec(0,0,1.0)*EyeScale,-vec(0,1,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.55,-0.75,1.0)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,5)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.25,1.125)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,0)))
            
            holoPos(105,This:toWorld(PLE+vec(0.55,1.25,1.25)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-5)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.0)*EyeScale,vec(0,-1,-1.5),0)
            holoClip(110,vec(0,0,1.0)*EyeScale,-vec(0,-1,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.55,0.75,1.0)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-5)))
            
            holoPos(107,This:toWorld(PRE+vec(0.75,-0.25,1.125)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,0)))
            
            holoPos(108,This:toWorld(PRE+vec(0.55,-1.25,1.25)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,5)))
            break
        case "smug",
            
            #Left Eye
            holoClip(28,vec(0,0,0.5)*EyeScale,vec(1.5,1,-1.5),0)
            holoClip(109,vec(0,0,0.5)*EyeScale,-vec(1.5,1,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.55,-0.75,1.0)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,5)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.25,1.35)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,0)))
            
            holoPos(105,This:toWorld(PLE+vec(0.55,1.25,1.125)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-5)))
            
            #Right Eye
            holoClip(29,vec(0,0,0.5)*EyeScale,vec(1.5,-1,-1.5),0)
            holoClip(110,vec(0,0,0.5)*EyeScale,-vec(1.5,-1,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.55,0.75,1.0)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-5)))
            
            holoPos(107,This:toWorld(PRE+vec(0.75,-0.25,1.35)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,0)))
            
            holoPos(108,This:toWorld(PRE+vec(0.55,-1.25,1.125)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,5)))
            
            break
        case "angry",
            #Left Eye
            holoClip(28,vec(0,0,1.5)*EyeScale,vec(0,1,-1),0)
            holoClip(109,vec(0,0,1.5)*EyeScale,-vec(0,1,-1),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.5,-1,1.25)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,15)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0,1.5)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,10)))
            
            holoPos(105,This:toWorld(PLE+vec(0.5,1,1.75)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,5)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.5)*EyeScale,vec(0,-1,-1),0)
            holoClip(110,vec(0,0,1.5)*EyeScale,-vec(0,-1,-1),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.5,1,1.25)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-15)))
            
            holoPos(107,This:toWorld(PRE+vec(0.75,0,1.5)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,-10)))
            
            holoPos(108,This:toWorld(PRE+vec(0.5,-1,1.75)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,-5)))
            
            break
        case "concerned",
        case "scared", #Guess who else is a filthy cheater?
            #Left Eye
            holoClip(28,vec(0,0,1.5)*EyeScale,vec(0,0.25,-1.5),0)
            holoClip(109,vec(0,0,1.5)*EyeScale,-vec(0,0.25,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.375,0,1.8)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,-10)))
            
            holoPos(104,This:toWorld(PLE+vec(0.6,0.75,1.625)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,-15)))
            
            holoPos(105,This:toWorld(PLE+vec(0.325,1.5,1.25)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-20)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.5)*EyeScale,vec(0,-0.25,-1.5),0)
            holoClip(110,vec(0,0,1.5)*EyeScale,-vec(0,-0.25,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.375,0,1.8)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,10)))
            
            holoPos(107,This:toWorld(PRE+vec(0.6,-0.75,1.625)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,15)))
            
            holoPos(108,This:toWorld(PRE+vec(0.325,-1.5,1.25)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,20)))
            
            
            break
        case "flustered",
            #Left Eye
            holoClip(28,vec(0,0,1)*EyeScale,vec(0,-0,-1.5),0)
            holoClip(109,vec(0,0,1)*EyeScale,-vec(0,-0,-1.5),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.5,-0.35,1.7)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,-10)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.66,1.2)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,-20)))
            
            holoPos(105,This:toWorld(PLE+vec(0.375,1.65,0.5)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-30)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.5)*EyeScale,vec(0,-1,-1.5),0)
            holoClip(110,vec(0,0,1.5)*EyeScale,-vec(0,-1,-1.5),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.375,0.75,1.5)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-5)))
            
            holoPos(107,This:toWorld(PRE+vec(0.675,-0.25,1.625)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,0)))
            
            holoPos(108,This:toWorld(PRE+vec(0.375,-1.25,1.625)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,5)))
            break
        case "worried",
            #Left Eye
            holoClip(28,vec(0,0,1.3)*EyeScale,vec(0,3,-6),0)
            holoClip(109,vec(0,0,1.3)*EyeScale,-vec(0,3,-6),0)
            
            holoPos(103,This:toWorld(PLE+vec(0.55,-0.75,1.6)*EyeScale))
            holoAng(103,This:toWorld(ang(45,0,5)))
            
            holoPos(104,This:toWorld(PLE+vec(0.75,0.25,1.5)*EyeScale))
            holoAng(104,This:toWorld(ang(45,0,0)))
            
            holoPos(105,This:toWorld(PLE+vec(0.55,1.25,1.4)*EyeScale))
            holoAng(105,This:toWorld(ang(45,0,-5)))
            
            #Right Eye
            holoClip(29,vec(0,0,1.3)*EyeScale,vec(0,-3,-6),0)
            holoClip(110,vec(0,0,1.3)*EyeScale,-vec(0,-3,-6),0)
            
            holoPos(106,This:toWorld(PRE+vec(0.55,0.75,1.6)*EyeScale))
            holoAng(106,This:toWorld(ang(45,0,-5)))
            
            holoPos(107,This:toWorld(PRE+vec(0.75,-0.25,1.5)*EyeScale))
            holoAng(107,This:toWorld(ang(45,0,0)))
            
            holoPos(108,This:toWorld(PRE+vec(0.55,-1.25,1.4)*EyeScale))
            holoAng(108,This:toWorld(ang(45,0,5)))
            break
        default,
            break
    }
    
    holoAlpha(109,((Wink==1)|Eyelids)*255)
    holoAlpha(110,((Wink==2)|Eyelids)*255)
    
    return void
}
function void entity:poseJaw(Angle,MinAngle,Scale){
    local HA = holoEntity(2)
    Angle = clamp(max(Angle,MinAngle),0,30)
    
    if(JawTheta < Angle){
        JawTheta = Angle
    }elseif(JawTheta > Angle){
        JawTheta += -10
        if(JawTheta <= Angle){JawTheta = Angle}
    }
    
    holoAng(35,HA:toWorld(ang(JawTheta,0,0)))
    holoPos(35,HA:toWorld(vec(6,0,-4 - JawTheta*4/30)*Scale))
    
    
    
    return void
}
function void entity:blep(BlepEnable, BlepAngle){ #Takes: jaw holo
    BlepAngle = clamp(BlepAngle,-60,60)
    if(BlepEnable & !Blepping){
        Blepping = 1
        foreach(K,Holo:number=TongueHolos){
            holoAlpha(Holo,255)
        }
        MinJawAngle = 15
    }elseif(!BlepEnable & Blepping){
        Blepping = 0
        holoAlpha(TongueLeftToothHolo,255)
        holoAlpha(TongueRightToothHolo,255)
        
        foreach(K,Holo:number=TongueHolos){
            holoAlpha(Holo,0)
        }
        MinJawAngle = 0
    }
    holoAng(119,This:toWorld(ang(0,BlepAngle,0)))
    
    if(Blepping){
        holoAlpha(TongueLeftToothHolo,((BlepAngle>35)|BlepAngle<-12) ? 255 : 0)
        holoAlpha(TongueRightToothHolo,((BlepAngle>12)|BlepAngle<-35) ? 255 : 0)
    }
}
#Mlem animation is in poseHead() further down
function void startMlem(){
    JawAngleMaster = 25
    MlemAngle = -15
    timer("startmlem",200)
}

function void cry(Cry){
    foreach(K,Holo:number=TearHolos){
        holoAlpha(Holo,Cry*TearColor:w())
    }
}
function void blush(CenterAlpha){
    if(CenterAlpha>0){
        BlushQ = 1
        foreach(K,Holo:number=BlushHolos){
            holoAlpha(Holo,CenterAlpha + 20*sin(BlushTheta))
        }
        BlushTheta += 15
        if(BlushTheta>=360){BlushTheta-=360}
    }elseif((CenterAlpha==0) & BlushQ){
        BlushQ = 0
        foreach(K,Holo:number=BlushHolos){
            holoAlpha(Holo,0)
        }
        BlushTheta = 0
    }
}

function void dytri(HoloIndex,Pos1:vector,Pos2:vector,Pos3:vector){
    local H = holoEntity(HoloIndex)
    local Center = (Pos1+Pos2+Pos3)/3

    local L12 = (Pos2-Pos1)
    local L23 = (Pos3-Pos2)
    local L13 = (Pos3-Pos1)
    
    local Normal = L12:cross(L23):normalized()
    local NA = Normal:toAngle()
    local NR = NA:rotateAroundAxis(NA:right(),-90)
    local Bearing = -bearing(Center,NR,Pos1)
    
    local Angle = NA:rotateAroundAxis(Normal,Bearing):rotateAroundAxis((Center-Pos1):cross(Normal),90)
    
    local FWD = Center-Pos1
    local Theta12 = acos((FWD:dot(L12))/(FWD:length()*L12:length()))
    local Adj12 = L12:length()*cos(Theta12)
    local Theta13 = acos((FWD:dot(L13))/(FWD:length()*L13:length()))
    local Adj13 = L13:length()*cos(Theta13)
    
    local SQS = max(Adj12,Adj13)
    local SQP = Pos1 + FWD:normalized()*SQS/2
    
    local CA12 = -L12:cross(Normal)
    local CA23 = -L23:cross(Normal)
    local CA13 = L13:cross(Normal)
    
    holoPos(HoloIndex,SQP)
    holoAng(HoloIndex,Angle)
    holoScale(HoloIndex,vec((SQS+6)/12,(SQS+6)/12,0.003125))
    
    holoClip(HoloIndex,1,H:toLocal(Pos1),H:toLocalAxis(CA12),0)
    holoClip(HoloIndex,2,H:toLocal(Pos2),H:toLocalAxis(CA23),0)
    holoClip(HoloIndex,3,H:toLocal(Pos1),H:toLocalAxis(CA13),0)
    return void
}
#This function would set up the entity-based wing clips, but isn't used because the wings tend to fall apart :(
#function void setupWingClips(){
#    local LH1 = holoEntity(70)
#    local LH2 = holoEntity(71)
#    local LH3 = holoEntity(72)
#    local LH4 = holoEntity(12)

#    holoScale(76,vec(4,4,0.03125))
#    holoClip(76,1,vec(),vec(-1,0,0),LH1)
#    holoClip(76,2,vec(),vec(1,0,0),LH2)
    
#    holoScale(77,vec(4,4,0.03125))
#    holoClip(77,1,vec(),vec(-1,0,0),LH2)
#    holoClip(77,2,vec(),vec(1,0,0),LH3)
    
#    holoScale(78,vec(4,4,0.03125))
#    holoClip(78,1,vec(),vec(-1,0,0),LH3)
#    holoClip(78,2,vec(),vec(-1,0,0),LH4)
    
#    local RH1 = holoEntity(80)
#    local RH2 = holoEntity(81)
#    local RH3 = holoEntity(82)
#    local RH4 = holoEntity(14)
    
#    holoScale(89,vec(4,4,0.03125))
#    holoClip(89,1,vec(),vec(-1,0,0),RH1)
#    holoClip(89,2,vec(),vec(1,0,0),RH2)
    
#    holoScale(90,vec(4,4,0.03125))
#    holoClip(90,1,vec(),vec(-1,0,0),RH2)
#    holoClip(90,2,vec(),vec(1,0,0),RH3)
    
#    holoScale(91,vec(4,4,0.03125))
#    holoClip(91,1,vec(),vec(-1,0,0),RH3)
#    holoClip(91,2,vec(),vec(-1,0,0),RH4)
#}
function void entity:poseWings(ShoulderYaw, ShoulderPitchUp, ShoulderRollUp, Splay, Flap, Offset, Scale){
    
    local JL = holoEntity(12)
    local JR = holoEntity(14)
    
    local ShoulderAngle1 = ang(0,-ShoulderYaw,0):rotateAroundAxis(vec(0,1,0),-ShoulderPitchUp)
    
    local ALS = ShoulderAngle1:rotateAroundAxis(vec(1,0,0),ShoulderRollUp + Offset)
    local ARS = (ShoulderAngle1:rotateAroundAxis(vec(1,0,0),ShoulderRollUp) - Offset)*ang(1,-1,-1)
    
    #local LH1 = ALS + ang(Flap*15, Splay + 90, 0)
    #local LH2 = ALS + ang(Flap*-15, Splay*2 + 90, 0)
    #local LH3 = ALS + ang(Flap-30, Splay*3 + 90, 0)
    
    local LH1 = ALS:rotateAroundAxis(ALS:up(),-Splay*3 + 180) + ang(0,0,Flap*60)
    local LH2 = ALS:rotateAroundAxis(ALS:up(),-Splay*2 + 180) + ang(0,0,Flap*40)
    local LH3 = ALS:rotateAroundAxis(ALS:up(),-Splay + 180) + ang(0,0,Flap*20)
    
    local RH1 = LH1*ang(1,-1,-1)
    local RH2 = LH2*ang(1,-1,-1)
    local RH3 = LH3*ang(1,-1,-1)
    
    holoAng(12,This:toWorld(ALS))
    holoAng(70,This:toWorld(LH1))
    holoAng(71,This:toWorld(LH2))
    holoAng(72,This:toWorld(LH3))
    
    holoAng(14,This:toWorld(ARS))
    holoAng(80,This:toWorld(RH1))
    holoAng(81,This:toWorld(RH2))
    holoAng(82,This:toWorld(RH3))
    
    local PLWH = JL:toWorld(vec(0,36,0)*Scale)
    local PLWJ = JL:pos()
    local PRWH = JR:toWorld(vec(0,-36,0)*Scale)
    local PRWJ = JR:pos()
    
    #Started making entity-based wing clip code, turns out it didn't work due to it coming apart when the wings flap.
    
    #local A76 = This:toWorld((LH1+LH2)/2)
    #local A77 = This:toWorld((LH2+LH3)/2)
    #local D3 = ((PLWH-47*This:toWorld(LH3):right())-PLWJ):normalized()
    #local A78 = This:toWorld(ALS:rotateAroundAxis(ALS:up(),acos((PLWH-PLWJ):normalized():dot(D3))))
    
    #holoPos(76,PLWH - 23*A76:right())
    #holoAng(76,A76)
    #holoPos(77,PLWH - 23*A77:right())
    #holoAng(77,A77)
    #holoPos(78,PLWJ + 25*A78:forward())
    #holoAng(78,A78)
    
    dytri(76,PLWH,PLWH-48*This:toWorld(LH1):right()*Scale,PLWH-48*This:toWorld(LH2):right()*Scale)
    dytri(77,PLWH,PLWH-48*This:toWorld(LH2):right()*Scale,PLWH-48*This:toWorld(LH3):right()*Scale)
    dytri(78,PLWH,PLWH-48*This:toWorld(LH3):right()*Scale,PLWJ)
    
    dytri(89,PRWH,PRWH+48*This:toWorld(RH1):right()*Scale,PRWH+48*This:toWorld(RH2):right()*Scale)
    dytri(90,PRWH,PRWH+48*This:toWorld(RH2):right()*Scale,PRWH+48*This:toWorld(RH3):right()*Scale)
    dytri(91,PRWH,PRWH+48*This:toWorld(RH3):right()*Scale,PRWJ)
    
    return void
}
function void entity:poseWingsCheap(ShoulderPitchUp, ShoulderYaw, ShoulderRollUp){
    
    local JL = holoEntity(12)
    local JR = holoEntity(14)
    
    #local ShoulderAngle = ang():rotateAroundAxis(vec(0,0,1),-ShoulderYaw):rotateAroundAxis(vec(1,0,0),ShoulderRollUp)
    #local ALS = ShoulderAngle
    #local ARS = ShoulderAngle*ang(1,-1,-1)
    
    local ShoulderAngle = ang(0,-ShoulderYaw,0):rotateAroundAxis(vec(0,1,0),-ShoulderPitchUp)
    
    local ALS = ShoulderAngle:rotateAroundAxis(vec(1,0,0),ShoulderRollUp)
    local ARS = ALS*ang(1,-1,-1)

    holoAng(12,This:toWorld(ALS))
    
    holoAng(14,This:toWorld(ARS))
    
    return void
}

function void entity:poseWingsDance(ShoulderPitchUp, ShoulderYaw, ShoulderRollUp, Offset){
    
    local JL = holoEntity(12)
    local JR = holoEntity(14)
    
    #local ShoulderAngle = ang():rotateAroundAxis(vec(0,0,1),-ShoulderYaw)
    
    #local ALS = ShoulderAngle:rotateAroundAxis(vec(1,0,0),ShoulderRollUp + Offset)
    #local ARS = (ShoulderAngle:rotateAroundAxis(vec(1,0,0),ShoulderRollUp) - Offset)*ang(1,-1,-1)

    local ShoulderAngle = ang(0,-ShoulderYaw,0):rotateAroundAxis(vec(0,1,0),-ShoulderPitchUp)
    
    local ALS = ShoulderAngle:rotateAroundAxis(vec(1,0,0),ShoulderRollUp + Offset)
    local ARS = (ShoulderAngle:rotateAroundAxis(vec(1,0,0),ShoulderRollUp) - Offset)*ang(1,-1,-1)

    holoAng(12,This:toWorld(ALS))
    
    holoAng(14,This:toWorld(ARS))
    
    return void
}

function angle entity:poseHead(HeadAngle:angle,NeckPitch){ #Inputs Local to Chip
    TP = HeadAngle:pitch()
    TY = HeadAngle:yaw()
    TR = HeadAngle:roll()
    
    #if(abs(TY)>90){TY = 0}
    #TY = clamp(TY,-135,135)
    TY = clamp(TY,-135,135)
    
    if(IT_Yaw < TY){
        IT_Yaw += clamp((TY-IT_Yaw)/2,0,30)
        if(IT_Yaw > TY){IT_Yaw = TY}
    }elseif(IT_Yaw > TY){
        IT_Yaw += -clamp((IT_Yaw-TY)/2,0,30)
        if(IT_Yaw < TY){IT_Yaw = TY}
    }
    
    if(IT_Pitch < TP){
        IT_Pitch += clamp((TP-IT_Pitch)/2,0,30)
        if(IT_Pitch > TP){IT_Pitch = TP}
    }elseif(IT_Pitch > TP){
        IT_Pitch += -clamp((IT_Pitch-TP)/2,0,30)
        if(IT_Pitch < TP){IT_Pitch = TP}
    }
    
    if(IT_Roll < TR){
        IT_Roll += clamp((TR-IT_Roll)/2,0,30)
        if(IT_Roll > TR){IT_Roll = TR}
    }elseif(IT_Roll > TR){
        IT_Roll += -clamp((IT_Roll-TR)/2,0,30)
        if(IT_Roll < TR){IT_Roll = TR}
    }
    if(Mlemming){
        MlemAngle += 5/Scale
        if(MlemAngle>=25){
            Mlemming = 0
            holoEntity(35):blep(0,0)
            if(MlemLoop){
                MlemAngle = -15
                timer("loopmlem",200)
            }else{
                MlemAngle = 0
                JawAngleMaster = 0
                timer("blink_open",100)
            }
        }
    }
    local HA = ang(IT_Pitch-MlemAngle,IT_Yaw,IT_Roll)
    local NA = ang(clamp(IT_Pitch/4 - NeckPitch,-60,60),clamp(IT_Yaw/4,-45,45),clamp(IT_Roll/4,-45,45))
    
    
    holoAng(1,holoEntity(0):toWorld(NA))
    holoAng(2,This:toWorld(HA))
    

    LanternTheta += 15
    if(LanternTheta>360){LanternTheta-=360}
    local LanternPos = 3*sin(LanternTheta)
    
    holoAng(116,This:toWorld(HA*ang(0,1,0))+ang(LanternPos,0,0))
    

    return HA
}
function angle entity:poseHeadInstant(HeadAngle:angle,NeckPitch){ #Inputs Local to Chip
    TP = HeadAngle:pitch()
    TY = HeadAngle:yaw()
    TR = HeadAngle:roll()
    
    #if(abs(TY)>90){TY = 0}
    #TY = clamp(TY,-135,135)
    TY = clamp(TY,-135,135)
    
    IT_Pitch = TP
    IT_Yaw = TY
    
    local HA = ang(TP,TY,TR)
    local NA = ang(clamp(TP/4 - NeckPitch,-60,60),clamp(TY/4,-45,45),clamp(TR/4,-45,45))
    
    
    holoAng(1,holoEntity(0):toWorld(NA))
    holoAng(2,This:toWorld(HA))
    holoAng(116,This:toWorld(HA*ang(0,1,0)))

    return HA
}
function void entity:poseStand(Scale){
    local Ang0 = This:angles()
    holoAng(0,Ang0)
    holoPos(0,This:toWorld(vec(0,0,-18 + 36*Scale)))
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    holoPos(1,holoEntity(0):toWorld(vec(27,0,0)*Scale))
    This:poseHead(ang(),0)
    BodyAngle = Ang0
    legReset()
    return void
}

function void entity:poseSitF(Scale){ #Sit like a Lady
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(-35,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18+5)*Scale)))
    
    holoAng(3,This:toWorld(ang(0,0,-4))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-5,0,-4)))
    holoAng(4,This:toWorld(ang(0,0,0)))
    
    holoAng(5,This:toWorld(ang(0,0,4))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-5,0,4)))
    holoAng(6,This:toWorld(ang(0,0,0)))
    
    holoAng(7,This:toWorld(ang(-150,30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(-30,-5,0)))
    holoAng(8,This:toWorld(ang(0,0,0)))
    
    holoAng(9,This:toWorld(ang(-150,-30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(-30,5,0)))
    holoAng(10,This:toWorld(ang(0,0,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    #holoEntity(0):poseTail(30,randint(-20,20))
    This:poseTail(-5,randint(-20,20),1,1,Scale)
    This:poseHead(ang(),0)
    
    return void
}
function void entity:poseSitM(Scale){ #Manspreading
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(-45,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + 18*Scale)))
    
    holoAng(3,This:toWorld(ang(-10,0,4))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-30,0,4)))
    holoAng(4,This:toWorld(ang(0,0,0)))
    
    holoAng(5,This:toWorld(ang(-10,0,-4))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-30,0,-4)))
    holoAng(6,This:toWorld(ang(0,0,0)))
    
    holoAng(7,This:toWorld(ang(-100,15,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(-80,10,0)))
    holoAng(8,This:toWorld(ang(-60,10,0)))
    
    holoAng(9,This:toWorld(ang(-100,-15,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(-80,-10,0)))
    holoAng(10,This:toWorld(ang(-60,-10,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-2.5,randint(-20,20),6,1,Scale)
    This:poseHead(ang(),0)
    
    return void
}
function void entity:poseLieF(Scale){ #Lying down like a lady
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(0,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18-3)*Scale)))
    
    holoAng(3,This:toWorld(ang(35,-30,2.5))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-90,-15,0)))
    holoAng(4,This:toWorld(ang(0,-15,0)))
    
    holoAng(5,This:toWorld(ang(35,30,-2.5))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-90,15,-0)))
    holoAng(6,This:toWorld(ang(0,15,0)))
    
    holoAng(7,This:toWorld(ang(-120,30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(30,15,0)))
    holoAng(8,This:toWorld(ang(0,5,0)))
    
    holoAng(9,This:toWorld(ang(-120,-30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(30,-15,0)))
    holoAng(10,This:toWorld(ang(0,-5,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-7.55,randint(-20,20),-4,2,Scale)
    This:poseHead(ang(),0)
    holoPos(1,holoEntity(0):toWorld(vec(27,0,0)*Scale))
    
    return void
}

function void entity:poseLieM(Scale){ #Lying down for maximum ball cooling
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(-5,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18-3)*Scale)))
    
    holoAng(3,This:toWorld(ang(-30,5,2.5))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-90,5,0)))
    holoAng(4,This:toWorld(ang(0,5,0)))
    
    holoAng(5,This:toWorld(ang(-30,-5,-2.5))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-90,-5,-0)))
    holoAng(6,This:toWorld(ang(0,-5,0)))
    
    holoAng(7,This:toWorld(ang(-80,30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(-65,15,0)))
    holoAng(8,This:toWorld(ang(0,5,0)))
    
    holoAng(9,This:toWorld(ang(-80,-30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(-65,-15,0)))
    holoAng(10,This:toWorld(ang(0,-5,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-5,randint(-20,20),-4,2,Scale)
    This:poseHead(ang(),0)
    holoPos(1,holoEntity(0):toWorld(vec(27,0,0)*Scale))
    
    return void
}

function void entity:poseSplat(Scale){ #Splat
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(0,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18-3)*Scale)))
    
    holoAng(3,This:toWorld(ang(-35,25,2.5))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-90,25,0)))
    holoAng(4,This:toWorld(ang(0,25,0)))
    
    holoAng(5,This:toWorld(ang(-35,-25,-2.5))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-90,-25,-0)))
    holoAng(6,This:toWorld(ang(0,-25,0)))
    
    holoAng(7,This:toWorld(ang(60,-30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(90,-15,0)))
    holoAng(8,This:toWorld(ang(135,-5,0)))
    
    holoAng(9,This:toWorld(ang(60,30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(90,15,0)))
    holoAng(10,This:toWorld(ang(135,5,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-5,randint(-5,5),-4,2,Scale)
    This:poseHead(ang(),0)
    holoPos(1,holoEntity(0):toWorld(vec(24,0,-4)*Scale))
    
    return void
}

function void entity:poseSploot(Scale){ #Sploot (Lie2), similar to poseSplat with larger random tail pose and narrower front paw pose
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    holoAng(0,This:toWorld(ang(0,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18-3)*Scale)))
    
    holoAng(3,This:toWorld(ang(-35,10,2.5))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-90,10,0)))
    holoAng(4,This:toWorld(ang(0,10,0)))
    
    holoAng(5,This:toWorld(ang(-35,-10,-2.5))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-90,-10,-0)))
    holoAng(6,This:toWorld(ang(0,-10,0)))
    
    holoAng(7,This:toWorld(ang(60,-30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(90,-15,0)))
    holoAng(8,This:toWorld(ang(135,-5,0)))
    
    holoAng(9,This:toWorld(ang(60,30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(90,15,0)))
    holoAng(10,This:toWorld(ang(135,5,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-5,randint(-20,20),-4,2,Scale)
    This:poseHead(ang(),0)
    holoPos(1,holoEntity(0):toWorld(vec(24,0,-4)*Scale))
    
    return void
}

function void entity:poseSleep1(Scale){ #Sleeping
    Climbing = 0 #Un-Crouch
    entity():posReset(vec(0,0,1),0,Scale)
    
    CurlDirection = (random()>0.5) ? 1 : -1 #1 for Left, -1 for Right
    
    holoAng(0,This:toWorld(ang(-5,0,0))) #Main Body
    holoPos(0,This:toWorld(vec(0,0,-18 + (18-3)*Scale)))
    
    holoAng(3,This:toWorld(ang(-30,5 - 30*CurlDirection,2.5))) #Front Left Leg
    holoAng(92,This:toWorld(ang(-90,5 - 30*CurlDirection,0)))
    holoAng(4,This:toWorld(ang(0,5 - 30*CurlDirection,0)))
    
    holoAng(5,This:toWorld(ang(-30,-5 - 30*CurlDirection,-2.5))) #Front Right Leg
    holoAng(93,This:toWorld(ang(-90,-5 - 30*CurlDirection,-0)))
    holoAng(6,This:toWorld(ang(0,-5 - 30*CurlDirection,0)))
    
    holoAng(7,This:toWorld(ang(-80,30,15))) #Rear Left Leg
    holoAng(94,This:toWorld(ang(-65,15,0)))
    holoAng(8,This:toWorld(ang(0,5,0)))
    
    holoAng(9,This:toWorld(ang(-80,-30,-15))) #Rear Right Leg
    holoAng(95,This:toWorld(ang(-65,-15,0)))
    holoAng(10,This:toWorld(ang(0,-5,0)))
    
    local Ang0 = This:angles()
    holoAng(102,Ang0)
    holoAng(111,Ang0)
    
    This:poseTail(-5,CurlDirection*20,-4,2,Scale)
    This:poseHead(ang(),0)
    holoPos(1,holoEntity(0):toWorld(vec(24,0,-4)*Scale))
    
    return void
}

function void vocalizeRoar(DefaultExpression:string,Sex,DoTimer,VoScale){
    switch(DefaultExpression){
        case "normal",
            soundPlay(5,2,"npc/antlion_guard/angry1.wav")
            Blinking = 1
            stoptimer("blink_close")
            stoptimer("blink_open")
            soundPitch(5,(90+10*Sex)/VoScale)
            JawAngleMaster = 30
            if(DoTimer){timer("roarend",2500)}
            break        
        case "happy",
            soundPlay(5,2,"npc/antlion_guard/angry1.wav")
            Blinking = 1
            stoptimer("blink_close")
            stoptimer("blink_open")
            soundPitch(5,(95+10*Sex)/VoScale)
            JawAngleMaster = 35
            if(DoTimer){timer("roarend",2500)}
            break
        case "sad",
            soundPlay(5,1.5,"npc/antlion_guard/antlion_guard_pain1.wav")
            soundPitch(5,(90+10*Sex)/VoScale)
            #soundPitch(5,70+15*Sex,2)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",2000)}
            break
        case "grumpy",
            soundPlay(5,1.5,"npc/antlion_guard/angry2.wav")
            soundPitch(5,(95+10*Sex)/VoScale)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        case "annoyed",
            soundPlay(5,1.5,"npc/antlion_guard/angry2.wav")
            soundPitch(5,(70+10*Sex)/VoScale)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        case "smug",
            soundPlay(5,1.5,"npc/antlion_guard/angry1.wav")
            soundPitch(5,(70+10*Sex)/VoScale)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",2500)}
            break
        case "angry",
            soundPlay(5,2,"npc/antlion_guard/angry3.wav")
            soundPitch(5,(80+10*Sex)/VoScale)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",2500)}
            break
        case "confused",
            soundPlay(5,1.5,"npc/antlion_guard/angry2.wav")
            soundPitch(5,(80+10*Sex)/VoScale)
            soundPitch(5,(105+10*Sex)/VoScale,1)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        case "flustered",
            soundPlay(5,1.5,"npc/antlion_guard/angry2.wav")
            soundPitch(5,(70+10*Sex)/VoScale)
            soundPitch(5,(95+10*Sex)/VoScale,1)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        case "concerned",
            soundPlay(5,1.5,"npc/antlion_guard/antlion_guard_pain2.wav")
            soundPitch(5,(90+10*Sex)/VoScale)
            #soundPitch(5,120+10*Sex,1)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        case "scared",
            soundPlay(5,3,"npc/antlion_guard/antlion_guard_die1.wav")
            soundPitch(5,(90+10*Sex)/VoScale)
            #soundPitch(5,120+10*Sex,1)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",3000)}
            break
        case "worried",
            soundPlay(5,1.5,"npc/antlion_guard/antlion_guard_pain2.wav")
            soundPitch(5,(80+10*Sex)/VoScale)
            JawAngleMaster = 25
            if(DoTimer){timer("roarend",1500)}
            break
        default,
            break
    }
    
    return void
}
function void vocalizeGroan(Sex,VoScale){
    soundPlay(5,4,"vo/npc/alyx/uggh01.wav")
    soundPitch(5,(15+5*Sex)/VoScale)
}
function string biteSound(Food:entity){
    
    local Snd = "physics/metal/metal_box_break1.wav"
    
    if(Food:type()=="prop_physics"){
        local PhysProp = Food:propPhysicalMaterial()
        
        if(PhysProp:find("metal")){
            Snd = select(randint(1,2),"physics/metal/metal_box_break1.wav","physics/metal/metal_box_break2.wav")
        }elseif(PhysProp:find("flesh") | PhysProp:find("watermelon")){
            Snd = select(randint(1,4),"physics/flesh/flesh_squishy_impact_hard1.wav","physics/flesh/flesh_squishy_impact_hard2.wav","physics/flesh/flesh_squishy_impact_hard3.wav","physics/flesh/flesh_squishy_impact_hard4.wav")
        }elseif(PhysProp:find("wood")){
            Snd = select(randint(1,5),"physics/wood/wood_crate_break1.wav","physics/wood/wood_crate_break2.wav","physics/wood/wood_crate_break3.wav","physics/wood/wood_crate_break4.wav","physics/wood/wood_crate_break5.wav")
        }elseif(PhysProp:find("glass")){
            Snd = select(randint(1,4),"physics/glass/glass_impact_bullet1.wav","physics/glass/glass_impact_bullet2.wav","physics/glass/glass_impact_bullet3.wav","physics/glass/glass_impact_bullet4.wav")
        }else{
            Snd = select(randint(1,2),"physics/metal/metal_box_break1.wav","physics/metal/metal_box_break2.wav")
        }
    }
    
    return Snd
}
function string mumble(Input:string){
    
    local Output = ""
    for(N=1,Input:length()){
        local Char = Input:index(N)
        
        if((Char==" ")|(Char==".")|(Char==",")|(Char=="!")|(Char=="?")|(Char=="\"")){
            Output += Char
        }elseif("ABCDEFGHIJKLMNOPQRSTUVWXYZ":find(Char)){
            Char = select(randint(1,4),"M","R","F","PH")
            Output += Char
        }else{
            Char = select(randint(1,4),"m","r","f","ph")
            Output += Char
        }
    }
    
    
    return Output
}
function string owo(Input:string){ #Child Speak
    local Output = ""
    for(N=1,Input:length()){
        local Char = Input:index(N)
        if((Char=="l")|(Char=="r")){
            Output += "w"
        }elseif((Char=="L")|(Char=="R")){
            Output += "W"
        }else{
            Output += Char
        }
    }
    return Output
}

function string olo(Input:string){ #Tongue Out Speak
    local Output = ""
    for(N=1,Input:length()){
        local Char = Input:index(N)
        if(Char=="b"){
            Output += "p"
        }elseif(Char=="B"){
            Output += "P"
        }elseif((Char=="s")|(Char=="f")){
            Output += "th"
        }elseif((Char=="S")|(Char=="F")){
            Output += "TH"
        }elseif(Char=="r"){
            Output += "l"
        }elseif(Char=="R"){
            Output += "L"
        }else{
            Output += Char
        }
    }
    return Output
}

function vector getAimPosFromTarget(Target:entity){
    local AimPos = vec()
    if(Target:isPlayer()){
        AimPos = Target:shootPos() - vec(0,0,6.5)*Scale
    }elseif(Target:type()=="gmod_wire_expression2"){
        local Wirelink = Target:wirelink()
        local HeadHolo = Wirelink["DragonHead",entity]
        
        if(HeadHolo){
            AimPos = HeadHolo:pos() - vec(0,0,6.5)*Scale
        }else{
            AimPos = AimPos = Target:boxCenterW() - vec(0,0,6.5)*Scale
        }
    }else{
        AimPos = Target:boxCenterW() - vec(0,0,6.5)*Scale
    }
    return AimPos
}
#print(olo("Sally sells sea shells by the seashore."))
