@name BeamNg.Drive HUD by Tyunge
@inputs  [EGP]:wirelink
@inputs  [Base]:entity
@inputs  [Active Gear ParkingBrake Brake HeadLight A D Rpm]:number
@outputs ScreenRes:vector2 Letter:string IndexAdd
@persist [I R N NeutralGear ReverseGear RedLine Mph Kmh RpmMult Q IndexMin IndexBump Z]:number
@trigger
 
##Made By Tyunge :3
 
#SetUp:
 
#       Step1:Spawn EGP
#       Step2:Link EGP to chair
#       Step3:Wire EGP from e2 to the EGP
#       Step4:Wire All the inputs on the e2 if u want
#       Step5:Reset E2
#       Step6:Profit
 
 
#If you want to remove the white rev thing on the rpm gauge goto line 260 :-)
 
if(first()|dupefinished())
{
   
    EGP:egpClear()
   
   
}
if(first())
{
 
#Set your screen resolution on ScreenRes mines 2560x1080, yours is most likly 1920x1080
 
                ScreenRes=vec2(2560,1080)
 
                NeutralGear = 0
                ReverseGear = 5
                RedLine     = 7000
                RpmMult     = 1000
                Kmh         = 1
                Mph         = 0
               
               
               
               
   
    #Large Greyish Circle Index = 1
    I++
    EGP:egpCircle(I,(ScreenRes/1.25),vec2(200,200))
    EGP:egpColor(I,vec4(36,36,36,100))
   
    #Smaller Center Whitish Circle Index = 2
    I++
    EGP:egpCircle(I,(ScreenRes/1.25),vec2(100,100))
    EGP:egpColor(I,vec4(200,200,200,25))
   
    #km/h & Mph text Index = 3
    I++
if(Kmh){
 
    EGP:egpText(I,"km/h",vec2(10,10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(0,0))
    EGP:egpAlign(I,1,1)
    EGP:egpFont(I,"Marlett",30)
    EGP:egpColor(I,vec4(200,200,200,150))
   
}
if(Mph){
 
    EGP:egpText(I,"mph",vec2(10,10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(0,0))
    EGP:egpAlign(I,1,1)
    EGP:egpFont(I,"Marlett",30)
    EGP:egpColor(I,vec4(200,200,200,150))
   
}
   
 
    #x1000 rpm Index = 4
    I++
    EGP:egpText(I,"x"+RpmMult+" RPM",vec2(10,10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(0,80))
    EGP:egpAlign(I,1,1)
    EGP:egpFont(I,"Marlett",20)
    EGP:egpColor(I,vec4(200,200,200,150))
   
    #Numbers 1-7 Index = 5,6,7,8,9,10,11
    while(I<4+(RedLine/1000))
    {
        I++
        N++
       
        Sin = sin((   240/(RedLine/1000)   )*N   )*120
        Cos = cos((   240/(RedLine/1000)   )*N   )*120
       
        EGP:egpText(I,""+N,vec2(10,10))
        EGP:egpPos(I,(ScreenRes/1.25)+vec2(-5-Sin,-10+Cos))
        EGP:egpFont(I,"Marlett",25)
        EGP:egpColor(I,vec4(255,255,255,255))    
       
        if((RedLine/1000)>7){IndexBump++ Z = -7 IndexAdd = IndexBump + Z}
        if((RedLine/1000)<7){IndexBump++ Z = 7 IndexAdd = IndexBump - Z}
            IndexAdd = clamp(IndexAdd,-5e10,5e10)
           
   
           
       
    }
   
    ##RpmOverlay
    while(I<27+IndexAdd)
    {  
        R++
        I++
        EGP:egpBox(I,(ScreenRes/1.25)+vec2(-sin( (270/16)*R-5 )*173,cos( (270/16)*R-5 )*173),vec2(59,40))
        EGP:egpAngle(I,(((-R/16)*270)-16.875)+22)
        EGP:egpColor(I,vec4(26,26,26,120))
       
        #RedLine
        EGP:egpColor(26+IndexAdd,vec4(127,0,0,140))
        EGP:egpColor(27+IndexAdd,vec4(127,0,0,140))
       
    }
    ##Gear
    I++
    EGP:egpText(I,""+Gear,vec2(10,10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(0,10))
    EGP:egpFont(I,"Marlett",60)
    EGP:egpColor(I,vec4(255,255,255,255))
   
    ##Speed
    I++
    EGP:egpText(I,"",vec2(10,10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(0,-75))
    EGP:egpFont(I,"Marlett",60)
    EGP:egpColor(I,vec4(255,255,255,255))
   
    #HeadLight
    I++
    EGP:egpWedge(I,(ScreenRes/1.25)+vec2(155,50),vec2(15,25))
    EGP:egpColor(I,vec4(30,30,30,255))
    EGP:egpSize(I,180)
    EGP:egpAngle(I,90)
   
    #Parking
    I++
    EGP:egpCircle(I,(ScreenRes/1.25)+vec2(135,100),vec2(15,15))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    ##Text P
    I++
    EGP:egpText(I,"P",vec2(10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(130,92))
    EGP:egpFont(I,"Marlett",20)
   
    #BrakeCircle
    I++
    EGP:egpCircle(I,(ScreenRes/1.25)+vec2(100,140),vec2(15,15))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    #Text ABS
    I++
    EGP:egpText(I,"ABS",vec2(10))
    EGP:egpPos(I,(ScreenRes/1.25)+vec2(89,133))
    EGP:egpFont(I,"Marlett",13)  
   
    #LeftArrow  
    I++
    Res = (ScreenRes/1.25)+vec2(10,170)
    EGP:egpTriangle(I,Res,Res+vec2(15,-10),Res+vec2(15,10))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    #LeftArrow Box
    I++
    EGP:egpBox(I,(ScreenRes/1.25)+vec2(30,170),vec2(10,10))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    #RightArrow
    I++
    Res = (ScreenRes/1.25)+vec2(70,160)
    EGP:egpTriangle(I,Res,Res-vec2(15,-10),Res-vec2(15,10))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    #RightArrow Box
    I++
    EGP:egpBox(I,(ScreenRes/1.25)+vec2(50,160),vec2(10,10))
    EGP:egpColor(I,vec4(30,30,30,255))
   
    ##OutLines :-)  
   
    ##OutLine Lights
    I++
    EGP:egpWedgeOutline(I,(ScreenRes/1.25)+vec2(155,50),vec2(15,25))
    EGP:egpColor(I,vec4(255,255,255,255))
    EGP:egpSize(I,180)
    EGP:egpAngle(I,90)
   
    ##Parking OutLine
    I++
    EGP:egpCircleOutline(I,(ScreenRes/1.25)+vec2(135,100),vec2(15,15))
    EGP:egpColor(I,vec4(255,255,255,255))
   
    ##Brake OutLine
    I++
    EGP:egpCircleOutline(I,(ScreenRes/1.25)+vec2(100,140),vec2(15,15))
    EGP:egpColor(I,vec4(255,255,255,255))
   
    ##Rpm BaseCenter
    I++
    EGP:egpBox(I,(ScreenRes/1.25),vec2(0))
   
    ##Rpm RedLine. not the red area, the litteral redLine that moves
    I++
    EGP:egpBox(I,vec2(0,175),vec2(5,45))
    EGP:egpColor(I,vec4(220,0,0,255))
    EGP:egpParent(I,42+IndexAdd)
}
interval( 1 )
if(Kmh){
Unit   =   round(toUnit("km/h",Base:vel():length()))
}
if(Mph){
Unit   =  round(toUnit("mph",Base:vel():length()))
}
timer("Blink",500)
 
if(clk("Blink")){Q++}
if(Q>1){Q=0}
 
#Gear
if(Gear==NeutralGear){Letter = "N"}
elseif(Gear==ReverseGear){Letter = "R"}
elseif(Gear>NeutralGear){Letter = ""+Gear}
if(ParkingBrake){Letter = "P"}
 
EGP:egpSetText(28+IndexAdd,""+Letter)
EGP:egpAlign(28+IndexAdd,1,0)
 
 
#Kmh
EGP:egpSetText(29+IndexAdd,""+Unit)
EGP:egpAlign(29+IndexAdd,1,0)
 
 
##Indicators
if(Brake){EGP:egpColor(33+IndexAdd,vec4(255,93,0,255))}else{EGP:egpColor(33+IndexAdd,vec4(30,30,30,255))}
if(ParkingBrake){EGP:egpColor(31+IndexAdd,vec4(255,93,0,255))}else{EGP:egpColor(31+IndexAdd,vec4(30,30,30,255))}
if(HeadLight){EGP:egpColor(30+IndexAdd,vec4(255,93,0,255))}else{EGP:egpColor(30+IndexAdd,vec4(30,30,30,255))}
 
if(A & Q){EGP:egpColor(35+IndexAdd,vec4(255,93,0,255)) EGP:egpColor(36+IndexAdd,vec4(255,93,0,255))}else{EGP:egpColor(35+IndexAdd,vec4(30,30,30,255)) EGP:egpColor(36+IndexAdd,vec4(30,30,30,255))}
 
if(D & Q){EGP:egpColor(37+IndexAdd,vec4(255,93,0,255)) EGP:egpColor(38+IndexAdd,vec4(255,93,0,255))}else{EGP:egpColor(37+IndexAdd,vec4(30,30,30,255)) EGP:egpColor(38+IndexAdd,vec4(30,30,30,255))}
 
 
EGP:egpAngle(42+IndexAdd,(Rpm/RedLine)*-240)
 
 
#CommentOut or remove all code under this comment if you want to remove the white Rpm thing when you rev
 
for(I = 12, 25)
{
    Color = (Rpm/RedLine)*vec4(200,200,200,255)
    Color = clamp(Color,vec4(26,26,26,120),vec4(200,200,200,255))
   
    Index = round(((Rpm/RedLine)*13)+12)
    Index = clamp(Index,14,24)
    EGP:egpColor(Index+IndexAdd,Color)
    EGP:egpColor(Index+1+IndexAdd,vec4(26,26,26,120))
   
}
