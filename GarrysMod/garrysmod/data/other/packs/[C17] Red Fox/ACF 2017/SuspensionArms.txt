@name Suspension Arms
@inputs Marker:array Base:entity
@outputs Cent:array Arc Mark:vector
@persist Cent:array Down Invert
@trigger 
runOnTick(1)

if(first()){
    Invert = 0
    
    Down = 5
    
    for(I = 1, Marker:count()){
        E = Marker[I, entity]
        
        #print(Local)
        
        holoCreate(I, E:pos())
        holoModel(I, "models/gibs/scanner_gib01.mdl")
        holoColor(I, vec(255,255,255))
        holoMaterial(I,"sprops/textures/sprops_chrome")
        
        Cent[I, vector] = Base:toLocal(E:massCenter()):setZ(-Down)
        #print(Cent)
        holoPos(I, Base:toWorld(Cent[I, vector] * vec(1, 0.55, 1)))
        
        holoAng(I, Base:toWorld(ang(0, -90 * sign(Cent[I, vector]:y()) * (Invert ? -1 : 1), 0)))
        
        Dist = holoEntity(I):pos():distance(E:pos()) / 2
        
        holoScale(I, vec(1.2, Dist / 6, 1))
        
        holoParent(I, Base)
    }
    
    for(I = Marker:count() + 1, Marker:count() * 2){
        holoCreate(I)
        holoScale(I, vec() + 0.1)
        
        Prev = holoEntity(I - Marker:count())
        holoPos(I, Base:toWorld((Cent[I - Marker:count(), vector] * vec(1, 0.55, 1)) 
        - vec(0, holoScale(I - Marker:count()):y() * 12 * sign(Cent[I - Marker:count(), vector]:y()), 0)))
        holoAng(I, Base:toWorld(ang(180, 0, 90 + (90 * sign(Cent[I - Marker:count(), vector]:y())))))
        
        holoParent((I - Marker:count()), I)
        holoParent(I, Base)
    }
}

for(I = 1, 4){
    E = Marker[I, entity]
    
    Mark = Base:toLocalAxis(holoEntity(I + Marker:count()):pos() - E:pos())
    Arc = atan(Mark[3], Mark[2])
    
    holoAng(I + Marker:count(), 
    Base:toWorld(ang(0, 0, Arc)))
}