@name Heli_HUDBase
@inputs Active [Pod EGP]:wirelink [Gun Gun2 Hull]:entity [CamAng]:angle [End]:vector [Valid]:number
@outputs 
@persist End2:vector [CompassPosition AmmoPInfoPosition AmmoSInfoPosition Res ResDriver]:vector2 Base:entity I J EndMarker AmmoMaxP AmmoMaxS TimeP TimeS FireRateP FireRateS ReloadingP ReloadingS CAmmoP CAmmoS
@persist CompassIndex HullIndex TurretIndex AmmoPBox AmmoSBox ReloadP ReloadS AmmoPS AmmoSS AmmoPRS AmmoSRS
@trigger Active EGP
@model

if(first()|dupefinished()){
    AmmoMaxP = Gun:acfAmmoCount()
    AmmoMaxS = Gun2:acfAmmoCount()
    #print(AmmoMax)
    #setName("Strichplatte fur das T.Z.F. 12a auf 2,5-fache und 5-fache VergroBerung einstellbar")
}
if( first() #[| changed(EGP)]# | changed(Active)&Active){
    
    #print(I)
    EGP:egpClear()
    EGP:egpDrawTopLeft(0)
    
    CompassPosition = vec2(700,280)
    AmmoPInfoPosition = vec2(700,400)
    AmmoSInfoPosition = vec2(700,460)
    
    Res = vec2(1920,1080)/2
    
    #ResDriver = vec2(1920,1080)/2
    ResDriver = egpScrSize(Pod["Entity",entity]:driver())/2
    #print(ResDriver)
    
    holoCreate(1,vec(),vec())
    
    I = 0
    
    local I = 1 
    EndMarker = I
    EGP:egpBox(I,vec2(),vec2())
    
    local I = I+1 
    EGP:egpCircleOutline(I,vec2(0),vec2(10))
    EGP:egpColor(I,vec4(200,60,60,255))
    EGP:egpSize(I,2)
    EGP:egpParent(I,EndMarker)
    
    local I = I+1 
    EGP:egpLine(I,vec2(-10),vec2(10))
    EGP:egpColor(I,vec(255))
    EGP:egpAlign(I,1,1)
    EGP:egpSize(I,1)
    EGP:egpParent(I,EndMarker)
    
    local I = I+1 
    EGP:egpLine(I,vec2(10,-10),vec2(-10,10))
    EGP:egpColor(I,vec(255))
    EGP:egpAlign(I,1,1)
    EGP:egpSize(I,1)
    EGP:egpParent(I,EndMarker)
    
    EGP:egp3DTracker(EndMarker,holoEntity(1):pos())
    EGP:egpParent(EndMarker,holoEntity(1))
    
    
    
    
    local I = I+1 
    EGP:egpBox(I,ResDriver,ResDriver*2)
    EGP:egpAlpha(I,70)
    EGP:egpColor(I,vec(0))
    
    local I = I+1 
    EGP:egpLine(I,(Res+vec2(-10,0))*vec2(ResDriver:x()/960,ResDriver:y()/540),(Res+vec2(10,0))*vec2(ResDriver:x()/960,ResDriver:y()/540))
    EGP:egpColor(I,vec(0))
    EGP:egpSize(I,4)
    
    local I = I+1 
    EGP:egpLine(I,(Res+vec2(0,-10))*vec2(ResDriver:x()/960,ResDriver:y()/540),(Res+vec2(0,10))*vec2(ResDriver:x()/960,ResDriver:y()/540))
    EGP:egpColor(I,vec(0))
    EGP:egpSize(I,4)
    
    local I = I+1 
    EGP:egpLine(I,(Res+vec2(-10,0))*vec2(ResDriver:x()/960,ResDriver:y()/540),(Res+vec2(10,0))*vec2(ResDriver:x()/960,ResDriver:y()/540))
    EGP:egpColor(I,vec(255,255,0))
    EGP:egpSize(I,2)
    
    local I = I+1 
    EGP:egpLine(I,(Res+vec2(0,-10))*vec2(ResDriver:x()/960,ResDriver:y()/540),(Res+vec2(0,10))*vec2(ResDriver:x()/960,ResDriver:y()/540))
    EGP:egpColor(I,vec(255,255,0))
    EGP:egpSize(I,2)
    
    local I = I+1 
    AmmoPInfoIndex = I
    EGP:egpBox(I,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(300,50))
    EGP:egpColor(I,vec(0))
    EGP:egpAlpha(I,150)
    
    local I = I+1 
    EGP:egpBox(I,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(200,32))
    EGP:egpColor(I,vec(220))
    EGP:egpAlpha(I,40)
    
    local I = I+1 
    AmmoSInfoIndex = I
    EGP:egpBox(I,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(300,50))
    EGP:egpColor(I,vec(0))
    EGP:egpAlpha(I,150)
    
    local I = I+1 
    EGP:egpBox(I,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(200,32))
    EGP:egpColor(I,vec(220))
    EGP:egpAlpha(I,40)
    
    
    EGP:egpDrawTopLeft(1)
    
    
    local I = I+1 
    AmmoPBox = I
    EGP:egpBox(I,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,-16),vec2(200,32))
    EGP:egpColor(I,vec(0,255,0))
    EGP:egpAlpha(I,150)

    local I = I+1 
    ReloadP = I
    EGP:egpBox(I,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,0),vec2(0,16))
    EGP:egpColor(I,vec(255,0,0))
    EGP:egpAlpha(I,255)
    
    local I = I+1 
    AmmoSBox = I
    EGP:egpBox(I,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,-16),vec2(200,32))
    EGP:egpColor(I,vec(0,255,0))
    EGP:egpAlpha(I,150)
    
    local I = I+1 
    ReloadS = I
    EGP:egpBox(I,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,0),vec2(0,16))
    EGP:egpColor(I,vec(255,0,0))
    EGP:egpAlpha(I,255)
    
    
    EGP:egpDrawTopLeft(0)
    
    local I = I+1 
    AmmoPS = I
    EGP:egpText(I,toString(Gun:acfAmmoCount()),(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-125,0))
    EGP:egpAlign(I,1,1)
    EGP:egpFont(I,"Arial",30*(ResDriver:x()/960))
    
    local I = I+1 
    AmmoSS = I
    EGP:egpText(I,toString(Gun2:acfAmmoCount()),(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-125,0))
    EGP:egpAlign(I,1,1)
    EGP:egpFont(I,"Arial",25*(ResDriver:x()/960))
    
    local I = I+1 
    AmmoPRS = I
    EGP:egpText(I,"9.9",(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(125,0))
    EGP:egpAlign(I,1,1)
    EGP:egpAlpha(I,0)
    EGP:egpFont(I,"Arial",25*(ResDriver:x()/960))
    
    local I = I+1 
    AmmoSRS = I
    EGP:egpText(I,"9.9",(Res+AmmoSInfoPosition+vec2(125,0))*vec2(ResDriver:x()/960,ResDriver:y()/540))
    EGP:egpAlign(I,1,1)
    EGP:egpAlpha(I,0)
    EGP:egpFont(I,"Arial",25)
    
    local I = I+1 
    EGP:egpCircle(I,(Res+CompassPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(75,75))
    EGP:egpColor(I,vec(50))
    EGP:egpAlpha(I,150)
    
    
    local I = I+1 
    CompassIndex = I
    EGP:egpCircleOutline(I,(Res+CompassPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(0))
    EGP:egpAlpha(I,0)
    
    local I = I+1 
    EGP:egpCircleOutline(I,vec2(0),vec2(54,54))
    EGP:egpColor(I,vec(180))
    EGP:egpAlpha(I,120)
    EGP:egpFidelity(I,20)
    EGP:egpSize(I,2)
    EGP:egpParent(I,I-1)
    
    for(D=0,360,22.5){
        J++
        BigL = (J+2)%4 == 0
        LittleL = J%2 == 0
        Angle = D/360*360+22.5
        Offset=0
        if(BigL){
            if(D > 100){
                Offset = 20
            }
            else {
                Offset = 10
            }
        }
        I++
        LinePos1 = vec2() - vec2(54,0):rotate(Angle)
        LinePos2 = vec2() - vec2(43 + (!BigL ? 0 : 5),0):rotate(Angle)
        EGP:egpLine(I, LinePos1, LinePos2)
        EGP:egpParent(I,CompassIndex)
        EGP:egpSize(I,(BigL ? 2 : 4))
        EGP:egpColor(I,LittleL ? BigL ? vec4(115,170,60,255) : vec4(170,60,60,255) : vec4(180,180,180,120))
    }
    J=0
    Offset = 0
    local I = I+1 
    EGP:egpText(I,"N",vec2(-4,-73))
    EGP:egpFont(I,"Arial",15)
    EGP:egpParent(I,CompassIndex)
    
    local I = I+1 
    EGP:egpText(I,"E",vec2(-4,-73):rotate(90)) 
    EGP:egpAngle(I,90)
    EGP:egpFont(I,"Arial",15)
    EGP:egpParent(I,CompassIndex)
    
    local I = I+1 
    EGP:egpText(I,"S",vec2(0,-73):rotate(180)) 
    EGP:egpFont(I,"Arial",15)
    EGP:egpAngle(I,180)
    EGP:egpParent(I,CompassIndex)
    
    local I = I+1 
    EGP:egpText(I,"W",vec2(-6,-73):rotate(270)) 
    EGP:egpFont(I,"Arial",15)
    EGP:egpAngle(I,270)
    EGP:egpParent(I,CompassIndex)
    
    local I = I+1 
    HullIndex = I
    EGP:egpCircleOutline(I,(Res+CompassPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(0))
    EGP:egpAlpha(I,0)
    
    local I = I+1 
    TDR = array(vec2(17,-20),vec2(17,20),vec2(-17,20),vec2(-17,-20),vec2(0,-28))
    EGP:egpPolyOutline(I,TDR)
    EGP:egpColor(I,vec4(115,170,60,255))
    EGP:egpSize(I,2)
    EGP:egpParent(I,HullIndex)
    
    local I = I+1 
    TurretIndex = I
    EGP:egpCircleOutline(I,(Res+CompassPosition+vec2(0,-3))*vec2(ResDriver:x()/960,ResDriver:y()/540),vec2(0))
    EGP:egpAlpha(I,0)
    
    local I = I+1 
    EGP:egpTriangleOutline(I,vec2(1,-30),vec2(10,0),vec2(-10,0))
    EGP:egpColor(I,vec4(115,170,60,255))
    EGP:egpSize(I,2)
    EGP:egpParent(I,TurretIndex)
    
    #print(I)
}
elseif(Active){
    
    holoPos(1,End)
    EGP:egpDrawTopLeft(1)
    if(changed(Gun:acfReady())){
        if(Gun:acfReady()){
            EGP:egpColor(AmmoPBox,vec(0,255,0))
        }
        else{
            EGP:egpColor(AmmoPBox,vec(0,255,255))
        }
    }
    if(changed(Gun2:acfReady())){
        if(Gun2:acfReady()){
            EGP:egpColor(AmmoSBox,vec(0,255,0))
        }
        else{
            EGP:egpColor(AmmoSBox,vec(0,255,255))
        }
    }
    EGP:egpDrawTopLeft(0)
    if(changed(Gun:acfAmmoCount())){
        if(Gun:acfAmmoCount()<CAmmoP){
            TimeP = curtime() + (60 / Gun:acfFireRate())
        }
        CAmmoP = Gun:acfAmmoCount()
        EGP:egpSetText(AmmoPS,toString(Gun:acfAmmoCount()))
        EGP:egpAlpha(AmmoPRS,255)
        ReloadingP = 1
    }
    if(ReloadingP == 1){
        EGP:egpDrawTopLeft(1)
        EGP:egpBox(AmmoPBox,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,-16),vec2(clamp(200*(Gun:acfAmmoCount()/AmmoMaxP),0,200),32))
        EGP:egpBox(ReloadP,(Res+AmmoPInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,0),vec2(clamp(200*((TimeP-curtime())/(60/Gun:acfFireRate())),0,200),16))
        EGP:egpDrawTopLeft(0)
        EGP:egpSetText(AmmoPRS,toString(round(TimeP-curtime(),1)))
        if(TimeP-curtime()<=0){
            ReloadingP = 0
            EGP:egpAlpha(AmmoPRS,0)
        }
    }
    
    if(changed(Gun2:acfAmmoCount())){
        if(Gun2:acfAmmoCount()<CAmmoS){
            TimeS = curtime() + (60 / Gun2:acfFireRate())
        }
        CAmmoS = Gun2:acfAmmoCount()
        EGP:egpSetText(AmmoSS,toString(Gun2:acfAmmoCount()))
        EGP:egpAlpha(AmmoSRS,255)
        ReloadingS = 1
    }
    if(ReloadingS == 1){
        EGP:egpDrawTopLeft(1)
        EGP:egpBox(AmmoSBox,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,-16),vec2(clamp(200*(Gun2:acfAmmoCount()/AmmoMaxS),0,200),32))
        EGP:egpBox(ReloadS,(Res+AmmoSInfoPosition)*vec2(ResDriver:x()/960,ResDriver:y()/540)+vec2(-100,0),vec2(clamp(200*((TimeS-curtime())/(60/Gun2:acfFireRate())),0,200),16))
        EGP:egpDrawTopLeft(0)
        EGP:egpSetText(AmmoSRS,toString(round(TimeS-curtime(),1)))
        if(TimeS-curtime()<=0){
            ReloadingS = 0
            EGP:egpAlpha(AmmoSRS,0)
        }
    }
    
    EGP:egpAngle(CompassIndex,-CamAng:yaw()+90)
    EGP:egpAngle(HullIndex,(Hull:angles():yaw()-90)+EGP:egpAngle(CompassIndex))
    EGP:egpAngle(TurretIndex,(Gun:angles():yaw()-90)+EGP:egpAngle(CompassIndex))
    holoPos(1,End)
    
    if(changed(Valid)){
        
    }
}

interval(100)
if(last()){
    EGP:egpClear()
}
if(dupefinished()|duped()){
    reset()
}
